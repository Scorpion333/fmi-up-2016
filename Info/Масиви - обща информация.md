# Масиви

Масивът е група от еднотипни елементи, които можем да обработваме заедно. Всеки елемент си има номер, с помощта на който го достъпваме.
Масивът винаги има определен размер - ако в началото напишем, че нашият масив има 10 елемента, не можем да добавим 11-ти.
(В случай, че все пак опитаме, е твърде вероятно да се случи нещо, която не искаме.)

Пример:

	int arr [10];
	arr [0] = 2;
	arr [1] = 3;
	arr [2] = 5;
	
	int k = 4;
	arr [k] = 11;
	
	arr [3] = 7;
	arr [5] = arr [4] + 2; 	    // Сега arr [5] става 13.
	
	cin >> arr [6]; 	    // Да речем, че сме въвели 17.
	cout << arr [2] << " " << arr [4] << " " << arr [5] << " " << arr [6] << endl;	    // На екрана: 5 11 13 17

Този пример показва няколко неща. Първо, за да декларираме масив, трябва да напишем:

	<типа на елементите> <името на масива> [ <броят на елементите> ];

В нашия случай имаме масив arr от 10 цели числа. За да достъпим някое от числата, пишем

	<името на масива> [ <номер на елемента> ]

Важно е да се отбележи, че елементите се броят от 0, затова arr може да има елемент с номер 9, но не и с номер 10.
Можем да поставим и променлива в квадратните скоби. Числата в масива се обработват по познатия начин - присвояваме им стойности,
включваме ги в аритметични изрази, въвеждаме ги, извежаме ги...

## Работа с всички елементи на масива

Не можем да работим с целия масив като с една променлива. Ако напишем това:

	int arr2 [10];
	arr2 = arr;

елементите на arr2 няма да станат равни на тези на arr.
(Тези два реда дори няма да се компилират, но и да се компилираха, резултатът от тях нямаше да е това, което искаме).
Ако искаме да направим нещо с всички елементи на масив, или с част от тях, трябва да използваме цикъл. Ето как ще направим първите 7 елемента на arr2 равни на тези на arr1:

	for (int i = 0; i < 7; i++)
	{
		arr2 [i] = arr [i];
	}

Прието е, когато пишем цикъл за масив, броячът да започва от 0 и условието да е записано с <. В случая лесно се вижда, че не сме пропуснали началния елемент и че сме изпълнили действията в цикъла точно 7 пъти, както искахме.

## Инициализация

Можем да дадем начална стойности на елементите в масива по следния начин:

	int masiv[5] = {8, 1, 3, 1, 8};		// По принцип не е хубаво да даваме имена на български, но...

	cout << masiv[0] << endl; 	// 8
	cout << masiv[1] << endl; 	// 1
	cout << masiv[2] << endl; 	// 3
	cout << masiv[3] << endl; 	// 1 - не е задължително числата да са различни
	cout << masiv[4] << endl; 	// 8

Ако в къдравите скоби отдясно напишем повече числа, ще получим грешка. Ако обаче напишем по-малко числа, останалите елементи на масива ще получат стойност по подразбиране - 0.

	int nov_masiv[5] = {8, 1, 3};

	cout << nov_masiv[0] << endl;	// 8
	cout << nov_masiv[1] << endl; 	// 1
	cout << nov_masiv[2] << endl; 	// 3
	cout << nov_masiv[3] << endl; 	// 0
	cout << nov_masiv[4] << endl; 	// 0

## Без размер

Ако инициализираме масив, можем да не напишем размера му - той автоматично ще стане точно толкова голям, колко броят на елементите отдясно. Квадратните скоби обаче трябва да присъстват:

	int arr_without_size [] = {2, 4, 6, 4};

	for (int i = 0; i < 4; i++)
	{
		cout << arr_without_size [i] << " ";
	} 
	// На екрана: 2 4 6 4

## Масиви от други типове

Масивите от реални числа работят по същия начин, но вместо int, пишем double. Същото важи за unsigned, long, long long, float и другите модификации на числовите типове.

Не е голяма разликата и когато имаме масив от булеви променливи. Тогава елементе имат две възможни стойности - true и false. Ако инициализираме масива с по-малко стойности, стойността по подразбиране за останалите елементи ще е false.

Пример:

	bool arr [3] = {true};
	cout << arr [0] << " " << arr [1] << " " << arr [2] << endl;	// На екрана: 1 0 0

	arr [0] = false;
	arr [1] = 5 + 4 > 7;		// arr [1] приема стойността на логическия израз вдясно, т.е. true.
	arr [2] = arr [0] && arr [1];	// arr [2] става false, защото arr [0] е false.

	cout << arr [0] << " " << arr [1] << " " << arr [2] << endl;	// На екрана: 0 1 0
