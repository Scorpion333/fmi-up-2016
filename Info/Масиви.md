#Масиви

Масивът е група от еднотипни елементи, които можем да обработваме заедно.
Всеки елемент си има номер, с помощта на който го достъпваме.
Масивът винаги има определен размер - ако в началото напишем, че нашият масив има 10 елемента,
не можем да добавим 11-ти. (В случай, че все пак опитаме, е твърде вероятно да се случи нещо,
която не искаме.)

Пример:

int arr[10];

arr[0] = 2;

arr[1] = 3;

arr[2] = 5;

int k = 4;

arr[k] = 11;

arr[3] = 7;

arr[5] = arr[4] + 2; // Сега arr[5] става 13.

cin >> arr[6]; // Например, 17.

cout << arr[2] << " " << arr[4] << " " << arr[5] << " " << arr[6] << endl;

На екрана ще се изведе: 5 11 13 17

Този пример показва няколко неща. Първо, за да декларираме масив, трябва да напишем:

<типа на елементите> <името на масива>  [ <броят на елементите> ];

В нашия случай имаме масив arr от 10 цели числа. За да достъпим някое от числата, пишем

<името на масива> [ <номер на елемента> ]

Важно е да се отбележи, че елементите се броят от 0, затова arr може да има елемент с номер 9, но не и с номер 10.
Можем да поставим и променлива в квадратните скоби. Числата в масива се обработват по познатия начин - 
присвояваме им стойности, включваме ги в аритметични изрази, въвеждаме ги, извежаме ги...

# Работа с всички елементи на масива

Не можем да работим с целия масив като с една променлива. Ако напишем това:

int arr2[10];
arr2 = arr;

елементите на arr2 няма да станат равни на тези на arr. (Тези два реда няма да се компилират, но дори и да се компилираха,
резултатът от тях нямаше да е това, което искаме). Ако искаме да направим нещо с всички елементи на масив, или с част от тях,
трябва да използваме цикъл. Ето как ще направим първите 7 елемента на arr2 равни на тези на arr1:

for(int i = 0; i < 7; i++)
{
	arr2[i] = arr[i];
}

Прието е, когато пишем цикъл за масив, броячът да започва от 0 и условието да е записано с <.
В случая лесно се вижда, че не сме пропуснали началния елемент и че сме изпълнили действията в цикъла точно 7 пъти, както искахме.

# Инициализация

Можем да дадем начална стойности на елементите в масива по следния начин:

int masiv[5] = {8, 1, 3, 1, 8}; // По принцип не е хубаво да даваме имена на български, но...

cout << masiv[0] << endl; // 8

cout << masiv[1] << endl; // 1

cout << masiv[2] << endl; // 3

cout << masiv[3] << endl; // 1 - не е задължително числата да са различни

cout << masiv[4] << endl; // 8

Ако в къдравите скоби отдясно напишем повече числа, ще получим грешка.
Ако обаче напишем по-малко числа, останалите елементи на масива ще получат стойност по подразбиране - 0.

int nov_masiv[5] = {8, 1, 3};

cout << nov_masiv[0] << endl; // 8

cout << nov_masiv[1] << endl; // 1

cout << nov_masiv[2] << endl; // 3

cout << nov_masiv[3] << endl; // 0

cout << nov_masiv[4] << endl; // 0

# Без размер

Ако инициализираме масив, можем да не напишем размера му - той автоматично ще стане точно толкова голям, колко броят
на елементите отдясно. Квадратните скоби обаче трябва да присъстват:

int arr_without_size[] = {2, 4, 6, 4}

for(int i = 0; i < 4; i++)
{
	cout << arr_without_size [i] << " ";
}
// На екрана: 2 4 6 4

# Масиви от други типове

Масивите от реални числа работят по същия начин, но вместо int, пишем double.
Същото важи за unsigned, long, long long, float и другите модификации на числовите типове.

Не е голяма разликата и когато имаме масив от булеви променливи. Тогава елементе имат две възможни стойности - true и false.
Ако инициализираме масива с по-малко стойности, стойността по подразбиране за останалите елементи ще е false.

Пример:

bool arr[3] = {true};

cout << arr[0] << " " << arr[1] << " " << arr[2] << endl; // На екрана: 1 0 0

arr[0] = false;

arr[1] = 5 + 4 > 7; // arr[1] приема стойността на логическия израз вдясно, т.е. true.

arr[2] = arr[0] && arr[1]; // arr[2] става false, защото arr[0] е false.

cout << arr[0] << " " << arr[1] << " " << arr[2] << endl; // На екрана: 0 1 0
