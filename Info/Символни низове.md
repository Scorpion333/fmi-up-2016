# Символни низове

Масивите от елементи от тип char се наричат още символни низове или стрингове.
Можем да работим с тях по същия начин, по който и с другите масиви:

	char array[6] = {'a', 'b', 'c', 'd'};
	
	array[1] = 'c';
	array[2] = 'd';
	array[3] = array[1];
	
	cout << array[0] << " " << array[1] << " " << array[2] << " " << array[3] << endl;	// На екрана: a c d c

	if (array[4] == '\0' && array[5] == '\0')
	{
		cout << "array[4] and array[5] are special zeros." << endl;
	}
	// На екрана: array[4] and array[5] are special zeros.

Както се вижда, array[4] и array[5] са получили стойност по подразбиране и това е символът '\0'.
Нарича се терминираща нула и има ASCII код 0. Тя има някои интересни свойства и
не може да бъде принтирана (ако напишем cout << '\0', нищо няма да стане). Затова се наложи да
проверим дали е там по друг начин.

## Втори начин на инициализация

Той е характерен само за масивите от тип char и се използва много по-често:

	char lang[] = "C++";

	cout << lang[0] << " " << lang[1] << " " << lang[2] << " ";

	if(lang[3] == '\0')
	{
		cout << "and something else" << endl;
	}
	// На екрана: C + + and something else

	char language[5] = "Java";

При този начин на инициализация, масивът автомътично получава допълнителен символ в края - '\0'.
Можем да зададем размер на низа, както правим на последния ред с language, но този раземр трябва да е поне с 1
по-голям от броя на символите вдясно, за да има място за една '\0'. Тя е важна, защото отбелязва края на масива.
Благодарение на нея със символните низове можем да правим неща, които не са възможни с другите масиви.
Например...

## Въвеждане и извеждане

Вместо да въвеждаме символите един по един, можем да напишем целия низ:

	char str[15];

	cin >> str;	// Да кажем, че напишем: FMI_is_great

	cout << str[0] << " " << str[1] << " " << str[2] << endl;	// На eкрана: F M I

Важно е символите, които въвеждаме тук да са по-малко от 15, за да остане място за '\0' накрая.
Задаването на начален размер е задължително - не можем оставим скобите на първия ред празни.
Също така, не трябва да пишем интервали в низа. Компютърът спира да чете в момента, в който напишем интервал.

Извеждането е лесно за разбиране:

	cout << str << endl;	// На екрана: FMI_is_great

## Библиотеката cstring

Има много вградени функции за работа със символни низове. Те са в библиотеката cstring, или string.h. Три от най-важните функции са:

- strlen (s) - дължината на низа s (броят символи преди '\0')
- strcpy (s1, s2) - низът s1 става равен на s2
- strcmp (s1, s2) - сравнява лексикографски два низа. Ако върне стойност 0, значи двата са еднакви.

Не можем да изпозваме оператор = и операторите за сравнение с масиви.
Ако искаме да сравняваме и присвояваме низове, трябва да използваме горните функции. 

## Библиотеката string

В С++ съществува тип string, който представлява символен низ с променлива дължина, с който може да се правят още повече
полезни операции (например да пишем =). За да го използваме, трябва да include-нем библиотеката string (не string.h, двете са различни!) ези стрингове не са част от курса по УП и няма да се разглеждат преди втори семестър.

До тогава библиотеката string е ЗАБРАНЕНА.
