# Символни низове

Наричат се още стрингове. Това са масиви с елементи от тип char.
С тях можем да извършваме същите операции, които и с другите масиви:

char symbols[6] = {'A', 'C', 'D', 'C'};

for(int i = 0; i < 4; i++)

{

	cout << symbols[i];

}

// На екрана: ACDC

if(symbols[4] == '\0')

	cout << "hmm... ";

if(symbols[5] == '\0')

	cout << "hmm... ";

// На екрана: hmm... hmm... 

Както се вижда, symbols[4] и symbols[5] са получили стойност по подразбиране и това е '\0' - символът с ASCII код 0.
Той се нарича терминираща 0. Тя има някои интересни свойства и не може да бъде принтирана (затова се наложи да проверим дали е там по по-особен начин).
Важно е да се отбележи, че тя е РАЗЛИЧНА от цифрата 0 - '0'. Двете не трябва да се бъркат.

# Специфични свойства на масивите от символи

Можем да инициализираме низ и по още един начин.

char arr[10] = "program";

Първите седем символа в arr стават равни на буквите в думата program, а останалите три стават '\0'.
Можем и да изпуснем числото в скобите:

char array[] = "program";

Сега array има не 7, а 8 символа - първите 7 са буквите от думата, последният е '\0'.

Прието е всеки път, когато декларираме символен низ, размерът му да е с 1 по-голям от броя символи, които ни трябват.
Причината - в края на масива ще има '\0', а нейното присъствие ни позволява да правим неща с низовете, които не можем с другите масиви.
Затова и при инициализация на низ без размер компилаторът автоматично слага '\0' в края.

Масивите от другите типове не могат да се извежат наведнъж - необходим ни е цикъл, за да изведем на екрана, например,
всички числа в масив от int-ове. С char обаче можем да използваме cout:

cout << array << endl; // На екрана: program

С++ има много вградени функции за работа със символни низове. Тези функции са в библиотеката cstring / string.h,
която трябва да се include-не в началото на програмата, ако искаме да я ползваме.
