#Символни низове

Масивите от елементи от тип char се наричат още символни низове или стрингове.
Можем да работим с тях по същия начин, по който и с другите масиви:

char array[6] = {'a', 'b', 'c', 'd'}

array[1] = 'c';

array[2] = 'd';

array[3] = array[1];

cout << array[0] << " " << array[1] << " " << array[2] << " " << array[3] << endl;

// На екрана: a c d c

if(array[4] == '\0' && array[5] == '\0')

	cout << "array[4] and array[5] are special zeros." << endl;


// На екрана: array[4] and array[5] are special zeros.

Както се вижда, array[4] и array[5] са получили стойност по подразбиране и това е '\0'.
Нарича се терминираща нула и има ASCII код 0. Тя има някои интересни свойства и
не може да бъде принтирана (ако напишем cout << '\0', нищо няма да стане). Затова се наложи да
проверим дали е там по друг начин.

#Втори начин на инициализация

Той е характерен само за масивите от тип char и се използва много по-често:

char lang[] = "C++";

cout << lang[0] << " " << lang[1] << " " << lang[2] << " ";

if(lang[3] == '\0')

	cout << "and something else" << endl;

// На екрана: C + + and something else

char language[5] = "Java"

При този начин на инициализация, масивът автомътично получава допълнителен символ в края - '\0'.
Можем да зададем размер на низа, както правим на последния ред с language, но този раземр трябва да е поне с 1
по-голям от броя на символите вдясно, за да има място за една '\0'. Тя е важна, защото отбелязва края на масива.
Благодарение на това със символните низове можем да правим неща, които не са възможни с другите масиви.
Например...

#Въвеждане и извеждане

Вместо да въвеждаме символите един по един, можем да напишем целия низ:

char str[15];

cin >> str; // Да кажем, че тук пишем: FMI_is_great

cout << str[0] << " " << str[1] << " " << str[2] << endl;

// На eкрана: F M I

Важно е символите, които въвеждаме тук да са по-малко от 15, за да остане място за '\0' накрая.
Задаването на начален размер е задължително - не можем оставим скобите на първия ред празни.
Също така, не трябва да пишем интервали в низа. Компютърът спира да чете в момента, в който напишем интервал.

Извеждането е лесно за разбиране:

cout << str << endl;

// На екрана: FMI_is_great

#include<cstring>

Има много вградени функции за работа със символни низове. Те са в библиотеката cstring, или string.h. Три от най-важните функции са:

- strlen (s) - дължината на низа s (броят символи преди '\0')
- strcpy (s1, s2) - низът s1 става равен на s2
- strcmp (s1, s2) - сравнява лексикографски два низа. Ако върне стойност 0, значи двата са еднакви.

Не можем да изпозваме оператор = и операторите за сравнение с масиви.
Ако искаме да ги сравняваме и присвояваме, трябва да използваме горните функции. 

#include<string>

В С++ съществува тип string, който представлява символен низ с променлива дължина, с който може да се правят още повече
полезни операции (например да пишем =). За да го използваме, трябва да include-нем библиотеката string (не string.h !).
Тези стрингове не са част от курса по УП и няма да се разглеждат преди втори семестър.

До тогава библиотеката string е ЗАБРАНЕНА.